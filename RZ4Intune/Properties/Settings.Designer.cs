//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace RuckZuck_Tool.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "16.3.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool UpgradeSettings {
            get {
                return ((bool)(this["UpgradeSettings"]));
            }
            set {
                this["UpgradeSettings"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool DisableBroadcast {
            get {
                return ((bool)(this["DisableBroadcast"]));
            }
            set {
                this["DisableBroadcast"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("")]
        public string CustomerID {
            get {
                return ((string)(this["CustomerID"]));
            }
            set {
                this["CustomerID"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool ShowAbout {
            get {
                return ((bool)(this["ShowAbout"]));
            }
            set {
                this["ShowAbout"] = value;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("https://graph.microsoft.com/beta/deviceAppManagement/mobileApps?$select=id,Displa" +
            "yName,notes&$filter=startswith(notes,\'RZID:\')")]
        public string RZGetExistingAppsURL {
            get {
                return ((string)(this["RZGetExistingAppsURL"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("DeviceManagementConfiguration.ReadWrite.All")]
        public string RZSecurityScope {
            get {
                return ((string)(this["RZSecurityScope"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("<#\r\n\r\n.COPYRIGHT\r\nCopyright (c) Microsoft Corporation. All rights reserved. Licen" +
            "sed under the MIT license.\r\nSee LICENSE in the project root for license informat" +
            "ion.\r\nhttps://github.com/microsoftgraph/powershell-intune-samples/tree/master/LO" +
            "B_Application\r\n#>\r\n\r\n####################################################\r\n\r\nfun" +
            "ction Get-AuthToken {\r\n\r\n    <#\r\n.SYNOPSIS\r\nThis function is used to authenticat" +
            "e with the Graph API REST interface\r\n.DESCRIPTION\r\nThe function authenticate wit" +
            "h the Graph API Interface with the tenant name\r\n.EXAMPLE\r\nGet-AuthToken\r\nAuthent" +
            "icates you with the Graph API interface\r\n.NOTES\r\nNAME: Get-AuthToken\r\n#>\r\n\r\n    " +
            "[cmdletbinding()]\r\n\r\n    param\r\n    (\r\n        [Parameter(Mandatory = $true)]\r\n " +
            "       $User\r\n    )\r\n\r\n    $userUpn = New-Object \"System.Net.Mail.MailAddress\" -" +
            "ArgumentList $User\r\n\r\n    $tenant = $userUpn.Host\r\n\r\n    Write-Host \"Checking fo" +
            "r AzureAD module...\"\r\n\r\n    $AadModule = Get-Module -Name \"AzureAD\" -ListAvailab" +
            "le\r\n\r\n    if ($AadModule -eq $null) {\r\n\r\n        Write-Host \"AzureAD PowerShell " +
            "module not found, looking for AzureADPreview\"\r\n        $AadModule = Get-Module -" +
            "Name \"AzureADPreview\" -ListAvailable\r\n\r\n    }\r\n\r\n    if ($AadModule -eq $null) {" +
            "\r\n        write-host\r\n        write-host \"AzureAD Powershell module not installe" +
            "d...\" -f Red\r\n        write-host \"Install by running \'Install-Module AzureAD\' or" +
            " \'Install-Module AzureADPreview\' from an elevated PowerShell prompt\" -f Yellow\r\n" +
            "        write-host \"Script can\'t continue...\" -f Red\r\n        write-host\r\n      " +
            "  exit\r\n    }\r\n\r\n    # Getting path to ActiveDirectory Assemblies\r\n    # If the " +
            "module count is greater than 1 find the latest version\r\n\r\n    if ($AadModule.cou" +
            "nt -gt 1) {\r\n\r\n        $Latest_Version = ($AadModule | select version | Sort-Obj" +
            "ect)[-1]\r\n\r\n        $aadModule = $AadModule | ? { $_.version -eq $Latest_Version" +
            ".version }\r\n\r\n        # Checking if there are multiple versions of the same modu" +
            "le found\r\n\r\n        if ($AadModule.count -gt 1) {\r\n\r\n            $aadModule = $A" +
            "adModule | select -Unique\r\n\r\n        }\r\n\r\n        $adal = Join-Path $AadModule.M" +
            "oduleBase \"Microsoft.IdentityModel.Clients.ActiveDirectory.dll\"\r\n        $adalfo" +
            "rms = Join-Path $AadModule.ModuleBase \"Microsoft.IdentityModel.Clients.ActiveDir" +
            "ectory.Platform.dll\"\r\n\r\n    }\r\n\r\n    else {\r\n\r\n        $adal = Join-Path $AadMod" +
            "ule.ModuleBase \"Microsoft.IdentityModel.Clients.ActiveDirectory.dll\"\r\n        $a" +
            "dalforms = Join-Path $AadModule.ModuleBase \"Microsoft.IdentityModel.Clients.Acti" +
            "veDirectory.Platform.dll\"\r\n\r\n    }\r\n\r\n    [System.Reflection.Assembly]::LoadFrom" +
            "($adal) | Out-Null\r\n\r\n    [System.Reflection.Assembly]::LoadFrom($adalforms) | O" +
            "ut-Null\r\n\r\n    $clientId = \"d1ddf0e4-d672-4dae-b554-9d5bdfd93547\"\r\n\r\n    $redire" +
            "ctUri = \"urn:ietf:wg:oauth:2.0:oob\"\r\n\r\n    $resourceAppIdURI = \"https://graph.mi" +
            "crosoft.com\"\r\n\r\n    $authority = \"https://login.microsoftonline.com/$Tenant\"\r\n\r\n" +
            "    try {\r\n\r\n        $authContext = New-Object \"Microsoft.IdentityModel.Clients." +
            "ActiveDirectory.AuthenticationContext\" -ArgumentList $authority\r\n\r\n        # htt" +
            "ps://msdn.microsoft.com/en-us/library/azure/microsoft.identitymodel.clients.acti" +
            "vedirectory.promptbehavior.aspx\r\n        # Change the prompt behaviour to force " +
            "credentials each time: Auto, Always, Never, RefreshSession\r\n\r\n        $platformP" +
            "arameters = New-Object \"Microsoft.IdentityModel.Clients.ActiveDirectory.Platform" +
            "Parameters\" -ArgumentList \"Auto\"\r\n\r\n        $userId = New-Object \"Microsoft.Iden" +
            "tityModel.Clients.ActiveDirectory.UserIdentifier\" -ArgumentList ($User, \"Optiona" +
            "lDisplayableId\")\r\n\r\n        $authResult = $authContext.AcquireTokenAsync($resour" +
            "ceAppIdURI, $clientId, $redirectUri, $platformParameters, $userId).Result\r\n\r\n   " +
            "     # If the accesstoken is valid then create the authentication header\r\n\r\n    " +
            "    if ($authResult.AccessToken) {\r\n\r\n            # Creating header for Authoriz" +
            "ation token\r\n\r\n            $authHeader = @{\r\n                \'Content-Type\'  = \'" +
            "application/json\'\r\n                \'Authorization\' = \"Bearer \" + $authResult.Acc" +
            "essToken\r\n                \'ExpiresOn\'     = $authResult.ExpiresOn\r\n            }" +
            "\r\n\r\n            return $authHeader\r\n\r\n        }\r\n\r\n        else {\r\n\r\n           " +
            " Write-Host\r\n            Write-Host \"Authorization Access Token is null, please " +
            "re-run authentication...\" -ForegroundColor Red\r\n            Write-Host\r\n        " +
            "    break\r\n\r\n        }\r\n\r\n    }\r\n\r\n    catch {\r\n\r\n        write-host $_.Exceptio" +
            "n.Message -f Red\r\n        write-host $_.Exception.ItemName -f Red\r\n        write" +
            "-host\r\n        break\r\n\r\n    }\r\n\r\n}\r\n \r\n#########################################" +
            "###########\r\n\r\nfunction CloneObject($object) {\r\n\r\n    $stream = New-Object IO.Me" +
            "moryStream;\r\n    $formatter = New-Object Runtime.Serialization.Formatters.Binary" +
            ".BinaryFormatter;\r\n    $formatter.Serialize($stream, $object);\r\n    $stream.Posi" +
            "tion = 0;\r\n    $formatter.Deserialize($stream);\r\n}\r\n\r\n##########################" +
            "##########################\r\n\r\nfunction WriteHeaders($authToken) {\r\n\r\n    foreach" +
            " ($header in $authToken.GetEnumerator()) {\r\n        if ($header.Name.ToLower() -" +
            "eq \"authorization\") {\r\n            continue;\r\n        }\r\n\r\n        Write-Host -F" +
            "oregroundColor Gray \"$($header.Name): $($header.Value)\";\r\n    }\r\n}\r\n\r\n##########" +
            "##########################################\r\n\r\nfunction MakeGetRequest($collectio" +
            "nPath) {\r\n\r\n    $uri = \"$baseUrl$collectionPath\";\r\n    $request = \"GET $uri\";\r\n\t" +
            "\r\n    if ($logRequestUris) { Write-Host $request; }\r\n    if ($logHeaders) { Writ" +
            "eHeaders $authToken; }\r\n\r\n    try {\r\n        Test-AuthToken\r\n        $response =" +
            " Invoke-RestMethod $uri -Method Get -Headers $authToken;\r\n        $response;\r\n  " +
            "  }\r\n    catch {\r\n        Write-Host -ForegroundColor Red $request;\r\n        Wri" +
            "te-Host -ForegroundColor Red $_.Exception.Message;\r\n        throw;\r\n    }\r\n}\r\n\r\n" +
            "####################################################\r\n\r\nfunction MakePatchReques" +
            "t($collectionPath, $body) {\r\n\r\n    MakeRequest \"PATCH\" $collectionPath $body;\r\n\r" +
            "\n}\r\n\r\n####################################################\r\n\r\nfunction MakePostR" +
            "equest($collectionPath, $body) {\r\n\r\n    MakeRequest \"POST\" $collectionPath $body" +
            ";\r\n\r\n}\r\n\r\n####################################################\r\n\r\nfunction MakeR" +
            "equest($verb, $collectionPath, $body) {\r\n\r\n    $uri = \"$baseUrl$collectionPath\";" +
            "\r\n    $request = \"$verb $uri\";\r\n\t\r\n    $clonedHeaders = CloneObject $authToken;\r" +
            "\n    $clonedHeaders[\"content-length\"] = $body.Length;\r\n    $clonedHeaders[\"conte" +
            "nt-type\"] = \"application/json\";\r\n\r\n    if ($logRequestUris) { Write-Host $reques" +
            "t; }\r\n    if ($logHeaders) { WriteHeaders $clonedHeaders; }\r\n    if ($logContent" +
            ") { Write-Host -ForegroundColor Gray $body; }\r\n\r\n    try {\r\n        Test-AuthTok" +
            "en\r\n        $response = Invoke-RestMethod $uri -Method $verb -Headers $clonedHea" +
            "ders -Body $body;\r\n        $response;\r\n    }\r\n    catch {\r\n        Write-Host -F" +
            "oregroundColor Red $request;\r\n        Write-Host -ForegroundColor Red $_.Excepti" +
            "on.Message;\r\n        throw;\r\n    }\r\n}\r\n\r\n#######################################" +
            "#############\r\n\r\nfunction UploadAzureStorageChunk($sasUri, $id, $body) {\r\n\r\n    " +
            "$uri = \"$sasUri&comp=block&blockid=$id\";\r\n    $request = \"PUT $uri\";\r\n\r\n    $iso" +
            " = [System.Text.Encoding]::GetEncoding(\"iso-8859-1\");\r\n    $encodedBody = $iso.G" +
            "etString($body);\r\n    $headers = @{\r\n        \"x-ms-blob-type\" = \"BlockBlob\"\r\n   " +
            " };\r\n\r\n    if ($logRequestUris) { Write-Host $request; }\r\n    if ($logHeaders) {" +
            " WriteHeaders $headers; }\r\n\r\n    try {\r\n        $response = Invoke-WebRequest $u" +
            "ri -Method Put -Headers $headers -Body $encodedBody;\r\n    }\r\n    catch {\r\n      " +
            "  Write-Host -ForegroundColor Red $request;\r\n        Write-Host -ForegroundColor" +
            " Red $_.Exception.Message;\r\n        throw;\r\n    }\r\n\r\n}\r\n\r\n######################" +
            "##############################\r\n\r\nfunction FinalizeAzureStorageUpload($sasUri, $" +
            "ids) {\r\n\r\n    $uri = \"$sasUri&comp=blocklist\";\r\n    $request = \"PUT $uri\";\r\n\r\n  " +
            "  $xml = \'<?xml version=\"1.0\" encoding=\"utf-8\"?><BlockList>\';\r\n    foreach ($id " +
            "in $ids) {\r\n        $xml += \"<Latest>$id</Latest>\";\r\n    }\r\n    $xml += \'</Block" +
            "List>\';\r\n\r\n    if ($logRequestUris) { Write-Host $request; }\r\n    if ($logConten" +
            "t) { Write-Host -ForegroundColor Gray $xml; }\r\n\r\n    try {\r\n        Invoke-RestM" +
            "ethod $uri -Method Put -Body $xml;\r\n    }\r\n    catch {\r\n        Write-Host -Fore" +
            "groundColor Red $request;\r\n        Write-Host -ForegroundColor Red $_.Exception." +
            "Message;\r\n        throw;\r\n    }\r\n}\r\n\r\n##########################################" +
            "##########\r\n\r\nfunction UploadFileToAzureStorage($sasUri, $filepath, $fileUri) {\r" +
            "\n\r\n    try {\r\n\r\n        $chunkSizeInBytes = 1024l * 1024l * $azureStorageUploadC" +
            "hunkSizeInMb;\r\n\t\t\r\n        # Start the timer for SAS URI renewal.\r\n        $sasR" +
            "enewalTimer = [System.Diagnostics.Stopwatch]::StartNew()\r\n\t\t\r\n        # Find the" +
            " file size and open the file.\r\n        $fileSize = (Get-Item $filepath).length;\r" +
            "\n        $chunks = [Math]::Ceiling($fileSize / $chunkSizeInBytes);\r\n        $rea" +
            "der = New-Object System.IO.BinaryReader([System.IO.File]::Open($filepath, [Syste" +
            "m.IO.FileMode]::Open));\r\n        $position = $reader.BaseStream.Seek(0, [System." +
            "IO.SeekOrigin]::Begin);\r\n\t\t\r\n        # Upload each chunk. Check whether a SAS UR" +
            "I renewal is required after each chunk is uploaded and renew if needed.\r\n       " +
            " $ids = @();\r\n\r\n        for ($chunk = 0; $chunk -lt $chunks; $chunk++) {\r\n\r\n    " +
            "        $id = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.Get" +
            "Bytes($chunk.ToString(\"0000\")));\r\n            $ids += $id;\r\n\r\n            $start" +
            " = $chunk * $chunkSizeInBytes;\r\n            $length = [Math]::Min($chunkSizeInBy" +
            "tes, $fileSize - $start);\r\n            $bytes = $reader.ReadBytes($length);\r\n\t\t\t" +
            "\r\n            $currentChunk = $chunk + 1;\t\t\t\r\n\r\n            Write-Progress -Acti" +
            "vity \"Uploading File to Azure Storage\" -status \"Uploading chunk $currentChunk of" +
            " $chunks\" `\r\n                -percentComplete ($currentChunk / $chunks * 100)\r\n\r" +
            "\n            $uploadResponse = UploadAzureStorageChunk $sasUri $id $bytes;\r\n\t\t\t\r" +
            "\n            # Renew the SAS URI if 7 minutes have elapsed since the upload star" +
            "ted or was renewed last.\r\n            if ($currentChunk -lt $chunks -and $sasRen" +
            "ewalTimer.ElapsedMilliseconds -ge 450000) {\r\n\r\n                $renewalResponse " +
            "= RenewAzureStorageUpload $fileUri;\r\n                $sasRenewalTimer.Restart();" +
            "\r\n\t\t\t\r\n            }\r\n\r\n        }\r\n\r\n        Write-Progress -Completed -Activity" +
            " \"Uploading File to Azure Storage\"\r\n\r\n        $reader.Close();\r\n\r\n    }\r\n\r\n    f" +
            "inally {\r\n\r\n        if ($reader -ne $null) { $reader.Dispose(); }\r\n\t\r\n    }\r\n\t\r\n" +
            "    # Finalize the upload.\r\n    $uploadResponse = FinalizeAzureStorageUpload $sa" +
            "sUri $ids;\r\n\r\n}\r\n\r\n####################################################\r\n\r\nfunct" +
            "ion RenewAzureStorageUpload($fileUri) {\r\n\r\n    $renewalUri = \"$fileUri/renewUplo" +
            "ad\";\r\n    $actionBody = \"\";\r\n    $rewnewUriResult = MakePostRequest $renewalUri " +
            "$actionBody;\r\n\t\r\n    $file = WaitForFileProcessing $fileUri \"AzureStorageUriRene" +
            "wal\" $azureStorageRenewSasUriBackOffTimeInSeconds;\r\n\r\n}\r\n\r\n#####################" +
            "###############################\r\n\r\nfunction WaitForFileProcessing($fileUri, $sta" +
            "ge) {\r\n\r\n    $attempts = 600;\r\n    $waitTimeInSeconds = 10;\r\n\r\n    $successState" +
            " = \"$($stage)Success\";\r\n    $pendingState = \"$($stage)Pending\";\r\n    $failedStat" +
            "e = \"$($stage)Failed\";\r\n    $timedOutState = \"$($stage)TimedOut\";\r\n\r\n    $file =" +
            " $null;\r\n    while ($attempts -gt 0) {\r\n        $file = MakeGetRequest $fileUri;" +
            "\r\n\r\n        if ($file.uploadState -eq $successState) {\r\n            break;\r\n    " +
            "    }\r\n        elseif ($file.uploadState -ne $pendingState) {\r\n            Write" +
            "-Host -ForegroundColor Red $_.Exception.Message;\r\n            throw \"File upload" +
            " state is not success: $($file.uploadState)\";\r\n        }\r\n\r\n        Start-Sleep " +
            "$waitTimeInSeconds;\r\n        $attempts--;\r\n    }\r\n\r\n    if ($file -eq $null -or " +
            "$file.uploadState -ne $successState) {\r\n        throw \"File request did not comp" +
            "lete in the allotted time.\";\r\n    }\r\n\r\n    $file;\r\n}\r\n\r\n########################" +
            "############################\r\n\r\nfunction GetWin32AppBody() {\r\n\r\n    param\r\n    (" +
            "\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"MSI\", Position = 1" +
            ")]\r\n        [Switch]$MSI,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetN" +
            "ame = \"EXE\", Position = 1)]\r\n        [Switch]$EXE,\r\n\r\n        [parameter(Mandato" +
            "ry = $true)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$displayName,\r" +
            "\n\r\n        [parameter(Mandatory = $true)]\r\n        [ValidateNotNullOrEmpty()]\r\n " +
            "       [string]$publisher,\r\n\r\n        [parameter(Mandatory = $true)]\r\n        [V" +
            "alidateNotNullOrEmpty()]\r\n        [string]$description,\r\n\r\n        [parameter(Ma" +
            "ndatory = $true)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$filename" +
            ",\r\n\r\n        [parameter(Mandatory = $true)]\r\n        [ValidateNotNullOrEmpty()]\r" +
            "\n        [string]$SetupFileName,\r\n\r\n        [parameter(Mandatory = $true)]\r\n    " +
            "    [ValidateSet(\'system\', \'user\')]\r\n        $installExperience = \"system\",\r\n\r\n " +
            "       [parameter(Mandatory = $false)]\r\n        [ValidateNotNullOrEmpty()]\r\n    " +
            "    [string]$imageValue,\r\n\r\n        [parameter(Mandatory = $false)]\r\n        [Va" +
            "lidateNotNullOrEmpty()]\r\n        $informationURL,\r\n\r\n        [parameter(Mandator" +
            "y = $false)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $developer,\r\n\r\n       " +
            " [parameter(Mandatory = $true, ParameterSetName = \"EXE\")]\r\n        [ValidateNotN" +
            "ullOrEmpty()]\r\n        $installCommandLine,\r\n\r\n        [parameter(Mandatory = $t" +
            "rue, ParameterSetName = \"EXE\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        $un" +
            "installCommandLine,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = " +
            "\"MSI\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        $MsiPackageType,\r\n\r\n       " +
            " [parameter(Mandatory = $true, ParameterSetName = \"MSI\")]\r\n        [ValidateNotN" +
            "ullOrEmpty()]\r\n        $MsiProductCode,\r\n\r\n        [parameter(Mandatory = $false" +
            ", ParameterSetName = \"MSI\")]\r\n        $MsiProductName,\r\n\r\n        [parameter(Man" +
            "datory = $true, ParameterSetName = \"MSI\")]\r\n        [ValidateNotNullOrEmpty()]\r\n" +
            "        $MsiProductVersion,\r\n\r\n        [parameter(Mandatory = $false, ParameterS" +
            "etName = \"MSI\")]\r\n        $MsiPublisher,\r\n\r\n        [parameter(Mandatory = $true" +
            ", ParameterSetName = \"MSI\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        $MsiRe" +
            "quiresReboot,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"MSI\")" +
            "]\r\n        [ValidateNotNullOrEmpty()]\r\n        $MsiUpgradeCode\r\n\r\n    )\r\n\r\n    i" +
            "f ($MSI) {\r\n\r\n        $body = @{ \"@odata.type\" = \"#microsoft.graph.win32LobApp\" " +
            "};\r\n        $body.applicableArchitectures = \"x64,x86\";\r\n        $body.descriptio" +
            "n = $description;\r\n        $body.developer = \"\";\r\n        $body.displayName = $d" +
            "isplayName;\r\n        $body.fileName = $filename;\r\n        $body.installCommandLi" +
            "ne = \"msiexec /i `\"$SetupFileName`\"\"\r\n        $body.installExperience = @{\"runAs" +
            "Account\" = \"$installExperience\" };\r\n        $body.informationUrl = $null;\r\n     " +
            "   $body.isFeatured = $false;\r\n        $body.minimumSupportedOperatingSystem = @" +
            "{\"v10_1607\" = $true };\r\n        $body.msiInformation = @{\r\n            \"packageT" +
            "ype\"    = \"$MsiPackageType\";\r\n            \"productCode\"    = \"$MsiProductCode\";\r" +
            "\n            \"productName\"    = \"$MsiProductName\";\r\n            \"productVersion\"" +
            " = \"$MsiProductVersion\";\r\n            \"publisher\"      = \"$MsiPublisher\";\r\n     " +
            "       \"requiresReboot\" = \"$MsiRequiresReboot\";\r\n            \"upgradeCode\"    = " +
            "\"$MsiUpgradeCode\"\r\n        };\r\n        $body.notes = \"\";\r\n        $body.owner = " +
            "\"\";\r\n        $body.privacyInformationUrl = $null;\r\n        $body.publisher = $pu" +
            "blisher;\r\n        $body.runAs32bit = $false;\r\n        $body.setupFilePath = $Set" +
            "upFileName;\r\n        $body.uninstallCommandLine = \"msiexec /x `\"$MsiProductCode`" +
            "\"\"\r\n\r\n    }\r\n\r\n    elseif ($EXE) {\r\n\r\n        $body = @{ \"@odata.type\" = \"#micro" +
            "soft.graph.win32LobApp\" };\r\n        $body.description = $description;\r\n        $" +
            "body.developer = $developer;\r\n        $body.displayName = $displayName;\r\n       " +
            " $body.fileName = $filename;\r\n        $body.informationUrl = $informationUrl;\r\n " +
            "       $body.installCommandLine = \"$installCommandLine\"\r\n        $body.installEx" +
            "perience = @{\"runAsAccount\" = \"$installExperience\" };\r\n        $body.isFeatured " +
            "= $false;\r\n        $body.minimumSupportedOperatingSystem = @{\"v10_1607\" = $true " +
            "};\r\n        $body.msiInformation = $null;\r\n        $body.notes = \"\";\r\n        $b" +
            "ody.owner = \"\";\r\n        $body.privacyInformationUrl = $null;\r\n        $body.pub" +
            "lisher = $publisher;\r\n        $body.runAs32bit = $false;\r\n        $body.setupFil" +
            "ePath = $SetupFileName;\r\n        $body.uninstallCommandLine = \"$uninstallCommand" +
            "Line\"\r\n        if ($imageValue) {\r\n            $body.largeIcon = @{\"type\" = \"ima" +
            "ge/png\"; \"value\" = $imageValue };\r\n        }\r\n\r\n    }\r\n\r\n    $body;\r\n}\r\n\r\n######" +
            "##############################################\r\n\r\nfunction GetAppFileBody($name," +
            " $size, $sizeEncrypted, $manifest) {\r\n\r\n    $body = @{ \"@odata.type\" = \"#microso" +
            "ft.graph.mobileAppContentFile\" };\r\n    $body.name = $name;\r\n    $body.size = $si" +
            "ze;\r\n    $body.sizeEncrypted = $sizeEncrypted;\r\n    $body.manifest = $manifest;\r" +
            "\n    $body.isDependency = $false;\r\n\r\n    $body;\r\n}\r\n\r\n##########################" +
            "##########################\r\n\r\nfunction GetAppCommitBody($contentVersionId, $LobT" +
            "ype) {\r\n\r\n    $body = @{ \"@odata.type\" = \"#$LobType\" };\r\n    $body.committedCont" +
            "entVersion = $contentVersionId;\r\n\r\n    $body;\r\n\r\n}\r\n\r\n##########################" +
            "##########################\r\n\r\nFunction Test-SourceFile() {\r\n\r\n    param\r\n    (\r\n" +
            "        [parameter(Mandatory = $true)]\r\n        [ValidateNotNullOrEmpty()]\r\n    " +
            "    $SourceFile\r\n    )\r\n\r\n    try {\r\n\r\n        if (!(test-path \"$SourceFile\")) {" +
            "\r\n\r\n            Write-Host\r\n            Write-Host \"Source File \'$sourceFile\' do" +
            "esn\'t exist...\" -ForegroundColor Red\r\n            throw\r\n\r\n        }\r\n\r\n    }\r\n\r" +
            "\n    catch {\r\n\r\n        Write-Host -ForegroundColor Red $_.Exception.Message;\r\n " +
            "       Write-Host\r\n        break\r\n\r\n    }\r\n\r\n}\r\n\r\n##############################" +
            "######################\r\n\r\nFunction New-DetectionRule() {\r\n\r\n    [cmdletbinding()" +
            "]\r\n\r\n    param\r\n    (\r\n        [parameter(Mandatory = $true, ParameterSetName = " +
            "\"PowerShell\", Position = 1)]\r\n        [Switch]$PowerShell,\r\n\r\n        [parameter" +
            "(Mandatory = $true, ParameterSetName = \"MSI\", Position = 1)]\r\n        [Switch]$M" +
            "SI,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"File\", Position" +
            " = 1)]\r\n        [Switch]$File,\r\n\r\n        [parameter(Mandatory = $true, Paramete" +
            "rSetName = \"Registry\", Position = 1)]\r\n        [Switch]$Registry,\r\n\r\n        [pa" +
            "rameter(Mandatory = $true, ParameterSetName = \"PowerShell\")]\r\n        [ValidateN" +
            "otNullOrEmpty()]\r\n        [String]$ScriptFile,\r\n\r\n        [parameter(Mandatory =" +
            " $true, ParameterSetName = \"PowerShell\")]\r\n        [ValidateNotNullOrEmpty()]\r\n " +
            "       $enforceSignatureCheck,\r\n\r\n        [parameter(Mandatory = $true, Paramete" +
            "rSetName = \"PowerShell\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        $runAs32B" +
            "it,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"MSI\")]\r\n       " +
            " [ValidateNotNullOrEmpty()]\r\n        [String]$MSIproductCode,\r\n   \r\n        [par" +
            "ameter(Mandatory = $true, ParameterSetName = \"File\")]\r\n        [ValidateNotNullO" +
            "rEmpty()]\r\n        [String]$Path,\r\n \r\n        [parameter(Mandatory = $true, Para" +
            "meterSetName = \"File\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$Fi" +
            "leOrFolderName,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"Fil" +
            "e\")]\r\n        [ValidateSet(\"notConfigured\", \"exists\", \"modifiedDate\", \"createdDa" +
            "te\", \"version\", \"sizeInMB\")]\r\n        [string]$FileDetectionType,\r\n\r\n        [pa" +
            "rameter(Mandatory = $false, ParameterSetName = \"File\")]\r\n        $FileDetectionV" +
            "alue = $null,\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"File\"" +
            ")]\r\n        [ValidateSet(\"True\", \"False\")]\r\n        [string]$check32BitOn64Syste" +
            "m = \"False\",\r\n\r\n        [parameter(Mandatory = $true, ParameterSetName = \"Regist" +
            "ry\")]\r\n        [ValidateNotNullOrEmpty()]\r\n        [String]$RegistryKeyPath,\r\n\r\n" +
            "        [parameter(Mandatory = $true, ParameterSetName = \"Registry\")]\r\n        [" +
            "ValidateSet(\"notConfigured\", \"exists\", \"doesNotExist\", \"string\", \"integer\", \"ver" +
            "sion\")]\r\n        [string]$RegistryDetectionType,\r\n\r\n        [parameter(Mandatory" +
            " = $false, ParameterSetName = \"Registry\")]\r\n        [ValidateNotNullOrEmpty()]\r\n" +
            "        [String]$RegistryValue,\r\n\r\n        [parameter(Mandatory = $true, Paramet" +
            "erSetName = \"Registry\")]\r\n        [ValidateSet(\"True\", \"False\")]\r\n        [strin" +
            "g]$check32BitRegOn64System = \"False\"\r\n\r\n    )\r\n\r\n    if ($PowerShell) {\r\n\r\n     " +
            "   if (!(Test-Path \"$ScriptFile\")) {\r\n            \r\n            Write-Host\r\n    " +
            "        Write-Host \"Could not find file \'$ScriptFile\'...\" -ForegroundColor Red\r\n" +
            "            Write-Host \"Script can\'t continue...\" -ForegroundColor Red\r\n        " +
            "    Write-Host\r\n            break\r\n\r\n        }\r\n        \r\n        $bReq = [Syste" +
            "m.Text.Encoding]::UTF8.GetBytes((Get-Content -Path $ScriptFile))\r\n        $Scrip" +
            "tContent = [System.Convert]::ToBase64String($bReq)\r\n        \r\n        $DR = @{ \"" +
            "@odata.type\" = \"#microsoft.graph.win32LobAppPowerShellScriptDetection\" }\r\n      " +
            "  $DR.enforceSignatureCheck = $false;\r\n        $DR.runAs32Bit = $false;\r\n       " +
            " $DR.scriptContent = \"$ScriptContent\";\r\n\r\n    }\r\n    \r\n    elseif ($MSI) {\r\n    " +
            "\r\n        $DR = @{ \"@odata.type\" = \"#microsoft.graph.win32LobAppProductCodeDetec" +
            "tion\" }\r\n        $DR.productVersionOperator = \"notConfigured\";\r\n        $DR.prod" +
            "uctCode = \"$MsiProductCode\";\r\n        $DR.productVersion = $null;\r\n\r\n    }\r\n\r\n  " +
            "  elseif ($File) {\r\n    \r\n        $DR = @{ \"@odata.type\" = \"#microsoft.graph.win" +
            "32LobAppFileSystemDetection\" }\r\n        $DR.check32BitOn64System = \"$check32BitO" +
            "n64System\";\r\n        $DR.detectionType = \"$FileDetectionType\";\r\n        $DR.dete" +
            "ctionValue = $FileDetectionValue;\r\n        $DR.fileOrFolderName = \"$FileOrFolder" +
            "Name\";\r\n        $DR.operator = \"notConfigured\";\r\n        $DR.path = \"$Path\"\r\n\r\n " +
            "   }\r\n\r\n    elseif ($Registry) {\r\n    \r\n        $DR = @{ \"@odata.type\" = \"#micro" +
            "soft.graph.win32LobAppRegistryDetection\" }\r\n        $DR.check32BitOn64System = \"" +
            "$check32BitRegOn64System\";\r\n        $DR.detectionType = \"$RegistryDetectionType\"" +
            ";\r\n        $DR.detectionValue = \"\";\r\n        $DR.keyPath = \"$RegistryKeyPath\";\r\n" +
            "        $DR.operator = \"notConfigured\";\r\n        $DR.valueName = \"$RegistryValue" +
            "\"\r\n\r\n    }\r\n\r\n    return $DR\r\n\r\n}\r\n\r\n###########################################" +
            "#########\r\n\r\nfunction Get-DefaultReturnCodes() {\r\n\r\n    @{\"returnCode\" = 0; \"typ" +
            "e\" = \"success\" }, `\r\n    @{\"returnCode\" = 1707; \"type\" = \"success\" }, `\r\n    @{\"" +
            "returnCode\" = 3010; \"type\" = \"softReboot\" }, `\r\n    @{\"returnCode\" = 1641; \"type" +
            "\" = \"hardReboot\" }, `\r\n    @{\"returnCode\" = 1618; \"type\" = \"retry\" }\r\n\r\n}\r\n\r\n###" +
            "#################################################\r\n\r\nfunction New-ReturnCode() {" +
            "\r\n\r\n    param\r\n    (\r\n        [parameter(Mandatory = $true)]\r\n        [int]$retu" +
            "rnCode,\r\n        [parameter(Mandatory = $true)]\r\n        [ValidateSet(\'success\'," +
            " \'softReboot\', \'hardReboot\', \'retry\')]\r\n        $type\r\n    )\r\n\r\n    @{\"returnCod" +
            "e\" = $returnCode; \"type\" = \"$type\" }\r\n\r\n}\r\n\r\n###################################" +
            "#################\r\n\r\nFunction Get-IntuneWinXML() {\r\n\r\n    param\r\n    (\r\n        " +
            "[Parameter(Mandatory = $true)]\r\n        $SourceFile,\r\n\r\n        [Parameter(Manda" +
            "tory = $true)]\r\n        $fileName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n " +
            "       [ValidateSet(\"false\", \"true\")]\r\n        [string]$removeitem = \"true\"\r\n   " +
            " )\r\n\r\n    Test-SourceFile \"$SourceFile\"\r\n\r\n    $Directory = [System.IO.Path]::Ge" +
            "tDirectoryName(\"$SourceFile\")\r\n\r\n    Add-Type -Assembly System.IO.Compression.Fi" +
            "leSystem\r\n    $zip = [IO.Compression.ZipFile]::OpenRead(\"$SourceFile\")\r\n\r\n    $z" +
            "ip.Entries | where { $_.Name -like \"$filename\" } | foreach {\r\n\r\n        [System." +
            "IO.Compression.ZipFileExtensions]::ExtractToFile($_, \"$Directory\\$filename\", $tr" +
            "ue)\r\n\r\n    }\r\n\r\n    $zip.Dispose()\r\n\r\n    [xml]$IntuneWinXML = gc \"$Directory\\$f" +
            "ilename\"\r\n\r\n    return $IntuneWinXML\r\n\r\n    if ($removeitem -eq \"true\") { remove" +
            "-item \"$Directory\\$filename\" }\r\n\r\n}\r\n\r\n#########################################" +
            "###########\r\n\r\nFunction Get-IntuneWinFile() {\r\n\r\n    param\r\n    (\r\n        [Para" +
            "meter(Mandatory = $true)]\r\n        $SourceFile,\r\n\r\n        [Parameter(Mandatory " +
            "= $true)]\r\n        $fileName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n      " +
            "  [string]$Folder = \"win32\"\r\n    )\r\n\r\n    $Directory = [System.IO.Path]::GetDire" +
            "ctoryName(\"$SourceFile\")\r\n\r\n    if (!(Test-Path \"$Directory\\$folder\")) {\r\n\r\n    " +
            "    New-Item -ItemType Directory -Path \"$Directory\" -Name \"$folder\" | Out-Null\r\n" +
            "\r\n    }\r\n\r\n    Add-Type -Assembly System.IO.Compression.FileSystem\r\n    $zip = [" +
            "IO.Compression.ZipFile]::OpenRead(\"$SourceFile\")\r\n\r\n    $zip.Entries | where { $" +
            "_.Name -like \"$filename\" } | foreach {\r\n\r\n        [System.IO.Compression.ZipFile" +
            "Extensions]::ExtractToFile($_, \"$Directory\\$folder\\$filename\", $true)\r\n\r\n    }\r\n" +
            "\r\n    $zip.Dispose()\r\n\r\n    return \"$Directory\\$folder\\$filename\"\r\n\r\n    if ($re" +
            "moveitem -eq \"true\") { remove-item \"$Directory\\$filename\" }\r\n\r\n}\r\n\r\n############" +
            "########################################\r\n\r\nfunction Upload-Win32Lob() {\r\n\r\n    " +
            "<#\r\n.SYNOPSIS\r\nThis function is used to upload a Win32 Application to the Intune" +
            " Service\r\n.DESCRIPTION\r\nThis function is used to upload a Win32 Application to t" +
            "he Intune Service\r\n.EXAMPLE\r\nUpload-Win32Lob \"C:\\Packages\\package.intunewin\" -pu" +
            "blisher \"Microsoft\" -description \"Package\"\r\nThis example uses all parameters req" +
            "uired to add an intunewin File into the Intune Service\r\n.NOTES\r\nNAME: Upload-Win" +
            "32LOB\r\n#>\r\n\r\n    [cmdletbinding()]\r\n\r\n    param\r\n    (\r\n        [parameter(Manda" +
            "tory = $true, Position = 1)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [strin" +
            "g]$SourceFile,\r\n\r\n        [parameter(Mandatory = $false)]\r\n        [ValidateNotN" +
            "ullOrEmpty()]\r\n        [string]$displayName,\r\n\r\n        [parameter(Mandatory = $" +
            "true, Position = 2)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$publi" +
            "sher,\r\n\r\n        [parameter(Mandatory = $true, Position = 3)]\r\n        [Validate" +
            "NotNullOrEmpty()]\r\n        [string]$description,\r\n\r\n        [parameter(Mandatory" +
            " = $true, Position = 4)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $detection" +
            "Rules,\r\n\r\n        [parameter(Mandatory = $true, Position = 5)]\r\n        [Validat" +
            "eNotNullOrEmpty()]\r\n        $returnCodes,\r\n\r\n        [parameter(Mandatory = $fal" +
            "se, Position = 6)]\r\n        [ValidateNotNullOrEmpty()]\r\n        [string]$install" +
            "CmdLine,\r\n\r\n        [parameter(Mandatory = $false, Position = 7)]\r\n        [Vali" +
            "dateNotNullOrEmpty()]\r\n        [string]$uninstallCmdLine,\r\n\r\n        [parameter(" +
            "Mandatory = $false, Position = 8)]\r\n        [ValidateSet(\'system\', \'user\')]\r\n   " +
            "     $installExperience = \"system\",\r\n\r\n        [parameter(Mandatory = $false, Po" +
            "sition = 9)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $imageValue,\r\n\r\n      " +
            "  [parameter(Mandatory = $false, Position = 10)]\r\n        [ValidateNotNullOrEmpt" +
            "y()]\r\n        $informationURL,\r\n\r\n        [parameter(Mandatory = $false, Positio" +
            "n = 11)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $developer,\r\n\r\n        [pa" +
            "rameter(Mandatory = $true, Position = 12)]\r\n        [ValidateNotNullOrEmpty()]\r\n" +
            "        $requirementRules,\r\n\r\n        [parameter(Mandatory = $true, Position = 1" +
            "3)]\r\n        [ValidateNotNullOrEmpty()]\r\n        $notes\r\n    )\r\n\r\n    try\t{\r\n\r\n " +
            "       $LOBType = \"microsoft.graph.win32LobApp\"\r\n\r\n        Write-Host \"Testing i" +
            "f SourceFile \'$SourceFile\' Path is valid...\" -ForegroundColor Yellow\r\n        Te" +
            "st-SourceFile \"$SourceFile\"\r\n\r\n        $Win32Path = \"$SourceFile\"\r\n\r\n        Wri" +
            "te-Host\r\n        Write-Host \"Creating JSON data to pass to the service...\" -Fore" +
            "groundColor Yellow\r\n\r\n        # Funciton to read Win32LOB file\r\n        $Detecti" +
            "onXML = Get-IntuneWinXML \"$SourceFile\" -fileName \"detection.xml\"\r\n\r\n        # If" +
            " displayName input don\'t use Name from detection.xml file\r\n        if ($displayN" +
            "ame) { $DisplayName = $displayName }\r\n        else { $DisplayName = $DetectionXM" +
            "L.ApplicationInfo.Name }\r\n        \r\n        $FileName = $DetectionXML.Applicatio" +
            "nInfo.FileName\r\n\r\n        $SetupFileName = $DetectionXML.ApplicationInfo.SetupFi" +
            "le\r\n\r\n        $Ext = [System.IO.Path]::GetExtension($SetupFileName)\r\n\r\n        i" +
            "f ((($Ext).contains(\"msi\") -or ($Ext).contains(\"Msi\")) -and (!$installCmdLine -o" +
            "r !$uninstallCmdLine)) {\r\n\r\n            # MSI\r\n            $MsiExecutionContext " +
            "= $DetectionXML.ApplicationInfo.MsiInfo.MsiExecutionContext\r\n            $MsiPac" +
            "kageType = \"DualPurpose\";\r\n            if ($MsiExecutionContext -eq \"System\") { " +
            "$MsiPackageType = \"PerMachine\" }\r\n            elseif ($MsiExecutionContext -eq \"" +
            "User\") { $MsiPackageType = \"PerUser\" }\r\n\r\n            $MsiProductCode = $Detecti" +
            "onXML.ApplicationInfo.MsiInfo.MsiProductCode\r\n            $MsiProductVersion = $" +
            "DetectionXML.ApplicationInfo.MsiInfo.MsiProductVersion\r\n            $MsiPublishe" +
            "r = $DetectionXML.ApplicationInfo.MsiInfo.MsiPublisher\r\n            $MsiRequires" +
            "Reboot = $DetectionXML.ApplicationInfo.MsiInfo.MsiRequiresReboot\r\n            $M" +
            "siUpgradeCode = $DetectionXML.ApplicationInfo.MsiInfo.MsiUpgradeCode\r\n          " +
            "  \r\n            if ($MsiRequiresReboot -eq \"false\") { $MsiRequiresReboot = $fals" +
            "e }\r\n            elseif ($MsiRequiresReboot -eq \"true\") { $MsiRequiresReboot = $" +
            "true }\r\n\r\n            $mobileAppBody = GetWin32AppBody `\r\n                -MSI `" +
            "\r\n                -displayName \"$DisplayName\" `\r\n                -publisher \"$pu" +
            "blisher\" `\r\n                -description $description `\r\n                -filena" +
            "me $FileName `\r\n                -SetupFileName \"$SetupFileName\" `\r\n             " +
            "   -installExperience $installExperience `\r\n                -MsiPackageType $Msi" +
            "PackageType `\r\n                -MsiProductCode $MsiProductCode `\r\n              " +
            "  -MsiProductName $displayName `\r\n                -MsiProductVersion $MsiProduct" +
            "Version `\r\n                -MsiPublisher $MsiPublisher `\r\n                -MsiRe" +
            "quiresReboot $MsiRequiresReboot `\r\n                -MsiUpgradeCode $MsiUpgradeCo" +
            "de\r\n\r\n        }\r\n\r\n        else {\r\n\r\n            $mobileAppBody = GetWin32AppBod" +
            "y -EXE -displayName \"$DisplayName\" -publisher \"$publisher\" `\r\n                -d" +
            "escription $description -filename $FileName -SetupFileName \"$SetupFileName\" `\r\n " +
            "               -installExperience $installExperience -installCommandLine $instal" +
            "lCmdLine `\r\n                -uninstallCommandLine $uninstallcmdline -imageValue " +
            "$imageValue `\r\n                -informationURL $informationURL -developer $devel" +
            "oper\r\n            if ($notes) { $mobileAppBody.notes = $notes }\r\n        }\r\n\r\n  " +
            "      if ($DetectionRules.\'@odata.type\' -contains \"#microsoft.graph.win32LobAppP" +
            "owerShellScriptDetection\" -and @($DetectionRules).\'@odata.type\'.Count -gt 1) {\r\n" +
            "            Write-Host\r\n            Write-Warning \"A Detection Rule can either b" +
            "e \'Manually configure detection rules\' or \'Use a custom detection script\'\"\r\n    " +
            "        Write-Warning \"It can\'t include both...\"\r\n            Write-Host\r\n      " +
            "      break\r\n        }\r\n        else {\r\n            $mobileAppBody | Add-Member " +
            "-MemberType NoteProperty -Name \'detectionRules\' -Value $detectionRules\r\n        " +
            "}\r\n\r\n        if ($requirementRules.\'@odata.type\' -contains \"#microsoft.graph.win" +
            "32LobAppPowerShellScriptRequirement\" -and @($requirementRules).\'@odata.type\'.Cou" +
            "nt -gt 1) {\r\n            Write-Host\r\n            Write-Warning \"A Detection Rule" +
            " can either be \'Manually configure requirement rules\' or \'Use a custom requireme" +
            "nt script\'\"\r\n            Write-Warning \"It can\'t include both...\"\r\n            W" +
            "rite-Host\r\n            break\r\n        }\r\n        else {\r\n            $mobileAppB" +
            "ody | Add-Member -MemberType NoteProperty -Name \'requirementRules\' -Value $requi" +
            "rementRules\r\n        }\r\n\r\n        #ReturnCodes\r\n\r\n        if ($returnCodes) {\r\n " +
            "       \r\n            $mobileAppBody | Add-Member -MemberType NoteProperty -Name " +
            "\'returnCodes\' -Value @($returnCodes)\r\n\r\n        }\r\n\r\n        else {\r\n\r\n         " +
            "   Write-Host\r\n            Write-Warning \"Intunewin file requires ReturnCodes to" +
            " be specified\"\r\n            Write-Warning \"If you want to use the default Return" +
            "Code run \'Get-DefaultReturnCodes\'\"\r\n            Write-Host\r\n            break\r\n\r" +
            "\n        }\r\n\r\n        Write-Host\r\n        Write-Host \"Creating application in In" +
            "tune...\" -ForegroundColor Yellow\r\n        $mobileApp = MakePostRequest \"mobileAp" +
            "ps\" ($mobileAppBody | ConvertTo-Json);\r\n\r\n        # Get the content version for " +
            "the new app (this will always be 1 until the new app is committed).\r\n        Wri" +
            "te-Host\r\n        Write-Host \"Creating Content Version in the service for the app" +
            "lication...\" -ForegroundColor Yellow\r\n        $appId = $mobileApp.id;\r\n        $" +
            "contentVersionUri = \"mobileApps/$appId/$LOBType/contentVersions\";\r\n        $cont" +
            "entVersion = MakePostRequest $contentVersionUri \"{}\";\r\n\r\n        # Encrypt file " +
            "and Get File Information\r\n        Write-Host\r\n        Write-Host \"Getting Encryp" +
            "tion Information for \'$SourceFile\'...\" -ForegroundColor Yellow\r\n\r\n        $encry" +
            "ptionInfo = @{ };\r\n        $encryptionInfo.encryptionKey = $DetectionXML.Applica" +
            "tionInfo.EncryptionInfo.EncryptionKey\r\n        $encryptionInfo.macKey = $Detecti" +
            "onXML.ApplicationInfo.EncryptionInfo.macKey\r\n        $encryptionInfo.initializat" +
            "ionVector = $DetectionXML.ApplicationInfo.EncryptionInfo.initializationVector\r\n " +
            "       $encryptionInfo.mac = $DetectionXML.ApplicationInfo.EncryptionInfo.mac\r\n " +
            "       $encryptionInfo.profileIdentifier = \"ProfileVersion1\";\r\n        $encrypti" +
            "onInfo.fileDigest = $DetectionXML.ApplicationInfo.EncryptionInfo.fileDigest\r\n   " +
            "     $encryptionInfo.fileDigestAlgorithm = $DetectionXML.ApplicationInfo.Encrypt" +
            "ionInfo.fileDigestAlgorithm\r\n\r\n        $fileEncryptionInfo = @{ };\r\n        $fil" +
            "eEncryptionInfo.fileEncryptionInfo = $encryptionInfo;\r\n\r\n        # Extracting en" +
            "crypted file\r\n        $IntuneWinFile = Get-IntuneWinFile \"$SourceFile\" -fileName" +
            " \"$filename\"\r\n\r\n        [int64]$Size = $DetectionXML.ApplicationInfo.Unencrypted" +
            "ContentSize\r\n        $EncrySize = (Get-Item \"$IntuneWinFile\").Length\r\n\r\n        " +
            "# Create a new file for the app.\r\n        Write-Host\r\n        Write-Host \"Creati" +
            "ng a new file entry in Azure for the upload...\" -ForegroundColor Yellow\r\n       " +
            " $contentVersionId = $contentVersion.id;\r\n        $fileBody = GetAppFileBody \"$F" +
            "ileName\" $Size $EncrySize $null;\r\n        $filesUri = \"mobileApps/$appId/$LOBTyp" +
            "e/contentVersions/$contentVersionId/files\";\r\n        $file = MakePostRequest $fi" +
            "lesUri ($fileBody | ConvertTo-Json);\r\n\t\r\n        # Wait for the service to proce" +
            "ss the new file request.\r\n        Write-Host\r\n        Write-Host \"Waiting for th" +
            "e file entry URI to be created...\" -ForegroundColor Yellow\r\n        $fileId = $f" +
            "ile.id;\r\n        $fileUri = \"mobileApps/$appId/$LOBType/contentVersions/$content" +
            "VersionId/files/$fileId\";\r\n        $file = WaitForFileProcessing $fileUri \"Azure" +
            "StorageUriRequest\";\r\n\r\n        # Upload the content to Azure Storage.\r\n        W" +
            "rite-Host\r\n        Write-Host \"Uploading file to Azure Storage...\" -f Yellow\r\n\r\n" +
            "        $sasUri = $file.azureStorageUri;\r\n        UploadFileToAzureStorage $file" +
            ".azureStorageUri \"$IntuneWinFile\" $fileUri;\r\n\r\n        # Need to Add removal of " +
            "IntuneWin file\r\n        $IntuneWinFolder = [System.IO.Path]::GetDirectoryName(\"$" +
            "IntuneWinFile\")\r\n        Remove-Item \"$IntuneWinFile\" -Force\r\n\r\n        # Commit" +
            " the file.\r\n        Write-Host\r\n        Write-Host \"Committing the file into Azu" +
            "re Storage...\" -ForegroundColor Yellow\r\n        $commitFileUri = \"mobileApps/$ap" +
            "pId/$LOBType/contentVersions/$contentVersionId/files/$fileId/commit\";\r\n        M" +
            "akePostRequest $commitFileUri ($fileEncryptionInfo | ConvertTo-Json);\r\n\r\n       " +
            " # Wait for the service to process the commit file request.\r\n        Write-Host\r" +
            "\n        Write-Host \"Waiting for the service to process the commit file request." +
            "..\" -ForegroundColor Yellow\r\n        $file = WaitForFileProcessing $fileUri \"Com" +
            "mitFile\";\r\n\r\n        # Commit the app.\r\n        Write-Host\r\n        Write-Host \"" +
            "Committing the file into Azure Storage...\" -ForegroundColor Yellow\r\n        $com" +
            "mitAppUri = \"mobileApps/$appId\";\r\n        $commitAppBody = GetAppCommitBody $con" +
            "tentVersionId $LOBType;\r\n        MakePatchRequest $commitAppUri ($commitAppBody " +
            "| ConvertTo-Json);\r\n\r\n        Write-Host \"Sleeping for $sleep seconds to allow p" +
            "atch completion...\" -f Magenta\r\n        Start-Sleep $sleep\r\n        Write-Host\r\n" +
            "    \r\n    }\r\n\t\r\n    catch {\r\n\r\n        Write-Host \"\";\r\n        Write-Host -Foreg" +
            "roundColor Red \"Aborting with exception: $($_.Exception.ToString())\";\r\n\t\r\n    }\r" +
            "\n}\r\n\r\n####################################################\r\n\r\nFunction Test-Auth" +
            "Token() {\r\n\r\n    # Checking if authToken exists before running authentication\r\n " +
            "   if ($global:authToken) {\r\n\r\n        # Setting DateTime to Universal time to w" +
            "ork in all timezones\r\n        $DateTime = (Get-Date).ToUniversalTime()\r\n\r\n      " +
            "  # If the authToken exists checking when it expires\r\n        $TokenExpires = ($" +
            "authToken.ExpiresOn.datetime - $DateTime).Minutes\r\n\r\n        if ($TokenExpires -" +
            "le 0) {\r\n\r\n            write-host \"Authentication Token expired\" $TokenExpires \"" +
            "minutes ago\" -ForegroundColor Yellow\r\n            write-host\r\n\r\n            # De" +
            "fining Azure AD tenant name, this is the name of your Azure Active Directory (do" +
            " not use the verified domain name)\r\n\r\n            if ($User -eq $null -or $User " +
            "-eq \"\") {\r\n\r\n                $Global:User = Read-Host -Prompt \"Please specify yo" +
            "ur user principal name for Azure Authentication\"\r\n                Write-Host\r\n\r\n" +
            "            }\r\n\r\n            $global:authToken = Get-AuthToken -User $User\r\n\r\n  " +
            "      }\r\n    }\r\n\r\n    # Authentication doesn\'t exist, calling Get-AuthToken func" +
            "tion\r\n\r\n    else {\r\n\r\n        if ($User -eq $null -or $User -eq \"\") {\r\n\r\n       " +
            "     $Global:User = Read-Host -Prompt \"Please specify your user principal name f" +
            "or Azure Authentication\"\r\n            Write-Host\r\n\r\n        }\r\n\r\n        # Getti" +
            "ng the authorization token\r\n        $global:authToken = Get-AuthToken -User $Use" +
            "r\r\n\r\n    }\r\n}\r\n\r\n####################################################\r\n\r\n\r\n#####" +
            "###############################################\r\n\r\n$baseUrl = \"https://graph.mic" +
            "rosoft.com/beta/deviceAppManagement/\"\r\n\r\n$logRequestUris = $true;\r\n$logHeaders =" +
            " $false;\r\n$logContent = $true;\r\n\r\n$azureStorageUploadChunkSizeInMb = 6l;\r\n\r\n$sle" +
            "ep = 30\r\n\r\n####################################################\r\n# Sample Win32 " +
            "Application\r\n####################################################\r\n# args0 = Sho" +
            "rtName string\r\n# args1 = Token string\r\n# args2 = ExpireTime string\r\n# args3 = Us" +
            "ername\r\n\r\n#Check if nuget provider is installed...\r\nif (-NOT (Get-PackageProvide" +
            "r nuget -ListAvailable -ea SilentlyContinue)) { Install-PackageProvider -Name \"N" +
            "uget\" -Force }\r\n\r\n#Install AzureAD Module if missing\r\ntry {\r\n    if ([version]((" +
            "(Get-Module -ListAvailable AzureAD) | Sort-Object version)[-1]).Version -lt \"2.0" +
            ".2.61\") { Install-Module AzureAD -Force -Confirm:$false }\r\n} catch { Install-Mod" +
            "ule AzureAD -Force -Confirm:$false }\r\n\r\n\r\n$ShortName = $args[0]\r\n#$global:authTo" +
            "ken = @{ \"Content-Type\" = \"application/json\"; \"Authorization\" = \"Bearer $($args[" +
            "1])\" ; \"ExpiresOn\" = [DateTimeOffset]::Parse($args[2]) }\r\n$Global:User = $args[3" +
            "]\r\n$global:authToken = Get-AuthToken -User $User\r\n$outFolder = \"$env:temp\\intune" +
            "win\"\r\nif (-NOT (Test-Path $outFolder)) { New-Item -Path $outFolder -ItemType Dir" +
            "ectory }\r\n#Remove-Item $sourceFolder -Recurse -Force -ea SilentlyContinue\r\n#New-" +
            "Item $sourceFolder -ItemType Directory -Force\r\n\r\n$url = Invoke-RestMethod -Uri \"" +
            "https://ruckzuck.tools/rest/v2/geturl\"\r\n $rzSW = Invoke-RestMethod -Uri \"$($url)" +
            "/rest/v2/getsoftwares?shortname=$([System.Web.HttpUtility]::UrlEncode($ShortName" +
            "))\" \r\n\r\n#rzSW can have multiple InstallTypes\r\nif ($rzSW.count -gt 1) {\r\n    #tak" +
            "e InstallType that matches the PreRequisites\r\n    $rzsw = $rzsw | ForEach-Object" +
            " { if ($_.PSPreReq | Invoke-Expression) { $_ } }\r\n}\r\n\r\n$sourceFolder = \"$env:tem" +
            "p\\$($rzSW.ContentID)\"\r\n$file = $rzSW.ShortName\r\n$rzSW.Files | ForEach-Object { \r" +
            "\n    #Invoke-WebRequest -Uri $_.URL -OutFile \"$($sourceFolder)\\$($_.FileName)\"\r\n" +
            "    $file = $_.FileName\r\n}\r\nif (-NOT (Test-Path $sourceFolder)) { New-Item -Path" +
            " $sourceFolder -ItemType Directory }\r\nInvoke-WebRequest -Uri $rzSW.iconURL -OutF" +
            "ile \"$($sourceFolder)\\logo.png\"\r\n\r\n#Download IntuneWinAppUtil\r\nif (-NOT (Test-Pa" +
            "th \"$($env:temp)\\IntuneWinAppUtil.exe\")) {\r\n    Invoke-WebRequest -Uri \"https://" +
            "raw.githubusercontent.com/microsoft/Microsoft-Win32-Content-Prep-Tool/master/Int" +
            "uneWinAppUtil.exe\" -OutFile \"$($env:temp)\\IntuneWinAppUtil.exe\"\r\n}\r\n&\"$($env:tem" +
            "p)\\IntuneWinAppUtil.exe\" -c $sourceFolder -s $file -o $outFolder -q\r\n\r\n$file = [" +
            "io.path]::GetFileNameWithoutExtension($file)\r\n$SourceFile = \"$($outFolder)\\$($fi" +
            "le).intunewin\"\r\n\r\n$img = [Convert]::ToBase64String((Invoke-WebRequest \"$($rzSW.i" +
            "conURL)&size=128\").Content)\r\n#$img = [Convert]::ToBase64String($rzSW.Image)\r\n\r\n#" +
            " Defining Intunewin32 detectionRules\r\n#$DetectionXML = Get-IntuneWinXML \"$Source" +
            "File\" -fileName \"detection.xml\"\r\n$PowerShellScript = \"$($sourceFolder)\\detection" +
            ".ps1\"\r\n$PowerShellRule = New-DetectionRule -PowerShell -ScriptFile \"$PowerShellS" +
            "cript\" -enforceSignatureCheck $false -runAs32Bit $false\r\n#$RegistryRule = New-De" +
            "tectionRule -Registry -RegistryKeyPath \"HKEY_LOCAL_MACHINE\\SOFTWARE\\App\" -Regist" +
            "ryDetectionType exists -check32BitRegOn64System True\r\n# Creating Array for detec" +
            "tion Rule\r\n$DetectionRule = @($PowerShellRule)\r\n$ReturnCodes = Get-DefaultReturn" +
            "Codes\r\n\r\n$type = \'system\'\r\nif ($rzSW.PSDetection.contains(\'HKCU:\')) { $type = \'u" +
            "ser\' }\r\n\r\n#requirements\r\n$bReq = [System.Text.Encoding]::UTF8.GetBytes((Get-Cont" +
            "ent -Path \"$($sourceFolder)\\requirements.ps1\"))\r\n$reqScript = [System.Convert]::" +
            "ToBase64String($bReq)\r\n$reqRule = @(@{\"@odata.type\"    = \"#microsoft.graph.win32" +
            "LobAppPowerShellScriptRequirement\";\r\n        \"operator\"              = \"equal\";\r" +
            "\n        \"detectionValue\"        = \"true\";\r\n        \"displayName\"           = \"r" +
            "equirements\";\r\n        \"enforceSignatureCheck\" = $false;\r\n        \"runAs32Bit\"  " +
            "          = $false;\r\n        \"runAsAccount\"          = $type;\r\n        \"scriptCo" +
            "ntent\"         = $reqScript;\r\n        \"detectionType\"         = \"boolean\"\r\n    }" +
            ")\r\n\r\n# Win32 Application Upload\r\nUpload-Win32Lob -SourceFile $SourceFile -displa" +
            "yName ($rzSW.ShortName + \" \" + $rzSW.ProductVersion) -publisher $rzSW.Manufactur" +
            "er `\r\n    -description $rzSW.Description -detectionRules $DetectionRule -returnC" +
            "odes $ReturnCodes `\r\n    -installCmdLine \"powershell.exe -ExecutionPolicy Bypass" +
            " .\\install.ps1\" `\r\n    -uninstallCmdLine \"powershell.exe -ExecutionPolicy Bypass" +
            " .\\uninstall.ps1\" `\r\n    -installExperience $type `\r\n    -imageValue $img `\r\n   " +
            " -requirementRules $reqRule `\r\n    -informationURL $rzSW.ProductURL `\r\n    -deve" +
            "loper \"RuckZuck\" `\r\n    -notes \"RZID:$($rzSW.SWId)`nShortName:$($rzSW.ShortName)" +
            "`nVersion:$($rzSW.ProductVersion)\"\r\n\r\n##########################################" +
            "##########")]
        public string RZCreateAppPS {
            get {
                return ((string)(this["RZCreateAppPS"]));
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("<?xml version=\"1.0\" encoding=\"utf-16\"?>\r\n<ArrayOfString xmlns:xsi=\"http://www.w3." +
            "org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" />")]
        public global::System.Collections.Specialized.StringCollection UpdExlusion {
            get {
                return ((global::System.Collections.Specialized.StringCollection)(this["UpdExlusion"]));
            }
            set {
                this["UpdExlusion"] = value;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("False")]
        public bool NoExit {
            get {
                return ((bool)(this["NoExit"]));
            }
        }
    }
}
